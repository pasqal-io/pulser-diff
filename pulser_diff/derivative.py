from __future__ import annotations

import torch
from torch import Tensor


def _fix_border_vals(deriv: Tensor, border_indices: list, dt: Tensor) -> Tensor:
    prev_idx = 0
    with torch.no_grad():
        for idx in border_indices:
            if idx == 0:
                deriv[0] = deriv[2] - ((deriv[2] - deriv[1]) / dt) * 2 * dt
                prev_idx = idx
            else:
                if (idx - prev_idx) != 1 or idx + 3 >= len(deriv):
                    deriv[idx - 1] = (
                        deriv[idx - 3]
                        + ((deriv[idx - 2] - deriv[idx - 3]) / dt) * 2 * dt
                    )
                    deriv[idx] = (
                        deriv[idx - 2]
                        + ((deriv[idx - 1] - deriv[idx - 2]) / dt) * 2 * dt
                    )
                else:
                    deriv[idx] = (
                        deriv[idx + 2]
                        - ((deriv[idx + 2] - deriv[idx + 1]) / dt) * 2 * dt
                    )
                prev_idx = idx
    return deriv


def deriv_time(f: Tensor, times: Tensor, pulse_endtimes: list | None = None) -> Tensor:
    """Calculate derivative with respect to time.

    Args:
        f (Tensor): time-dependent function
        times (Tensor): function evaluation times
        pulse_endtimes (list | None, optional): collection of times denoting
        start/end of pulses in sequence.
        Defaults to None.

    Returns:
        Tensor: derivative df/dt
    """

    res = torch.autograd.grad(f, times, torch.ones_like(f), retain_graph=True)[0]
    if pulse_endtimes is not None:
        # remove derivative artifacts from pulse boundaries
        # generated by piecewise-continuous pulse profiles
        dt = times[1] - times[0]
        res = _fix_border_vals(res, pulse_endtimes, dt)
    return res


def deriv_param(
    f: Tensor,
    x: list[Tensor],
    times: Tensor | None = None,
    t: int | float | None = None,
) -> Tensor:
    """Calculate derivative with respect to pulse parameter.

    Args:
        f (Tensor): time-dependent function
        x (list[Tensor]): list of pulse parameters on which function depends
        times (None | Tensor, optional): function evaluation times. Defaults to None.
        t (int | list[int], optional): a particular time (in ns)
        for which derivative is calculated. Defaults to None.

    Returns:
        torch.Tensor: derivative df/dx
    """
    v = torch.zeros(len(f))
    if times is None:
        # t is selected as final time moment
        v[-1] = 1.0
    else:
        # index of specified moment t in times tensor
        t = float(times[-1] if t is None else float(t) / 1000)
        idx = torch.abs(times - t).argmin()
        v[idx] = 1.0
    grad = torch.autograd.grad(f, x, v, retain_graph=True)

    return grad
